<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <style>
      html, body {
        width: 100%;
        height: 100%;
        margin: 0px;
        border: 0;
        overflow: hidden; /*  Disable scrollbars */
        display: block;  /* No floating content on sides */
      }
      </style>
  </head>

  <body>
    <canvas id="canvas" style='position:absolute; left:0px; top:0px; width: 100%'></canvas>

<script>

let sprites = [];

  // Returns an object containing resources that will be used later for drawing
  function resources() {
    let res = {
      player: document.createElement('canvas'),
      enemy: document.createElement('canvas'),
      bullet: document.createElement('canvas'),
      particle: document.createElement('canvas')
    }

    // Particle
    res.particle.width = 20;
    res.particle.height = 20;
    let pCtx = res.particle.getContext('2d');
    pCtx.fillStyle = "darkviolet";
    pCtx.beginPath();
    pCtx.arc(10, 10, 10, 0, 2 * Math.PI);
    pCtx.fill();

    // Bullet
    res.bullet.width = 6;
    res.bullet.height = 6;
    let bCtx = res.bullet.getContext('2d');
    bCtx.fillStyle = "blue";
    bCtx.beginPath();
    bCtx.arc(3, 3, 3, 0, 2 * Math.PI);
    bCtx.fill();

    // Enemy
    res.enemy.width = 20;
    res.enemy.height = 20;
    let eCtx = res.enemy.getContext('2d');
    eCtx.fillStyle = "yellow";
    eCtx.beginPath();
    eCtx.arc(10, 10, 10, 0, 2 * Math.PI);
    eCtx.fill();

    // Player
    res.player.width = 20;
    res.player.height = 16;
    let plCtx = res.player.getContext('2d');
    plCtx.fillStyle = "red";
    plCtx.beginPath();
    plCtx.lineTo(20, 8);
    plCtx.lineTo(0, 16);
    plCtx.lineTo(0, 0);
    plCtx.fill();

    return res;
  }

  // We create this here because it will be used from within `imports`
  let canvas = document.getElementById('canvas');

  // Returns an object containing functions that will be linked to our wasm model
  // This means that they can be called from Rust
  function imports() {
    const res = resources();
    var ctx = canvas.getContext("2d");

    function clear_screen() {
      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function draw_player(x, y, angle) {
      ctx.translate(x, y);
      ctx.rotate(angle);
      ctx.translate(0, -8);
      ctx.drawImage(res.player, 0, 0);
      ctx.setTransform(1, 0, 0, 1, 0, 0);


      ctx.fillStyle = "black";
      //ctx.fillRect(x - 17, y - 12, 4, 4);
    }


    function draw_bullet(x, y) {
      ctx.drawImage(res.bullet, x - 3, y - 3);
    }

    function draw_particle(x, y, radius) {
      ctx.drawImage(res.particle, x - radius, y - radius, 2 * radius, 2 * radius);
    }

	function draw_intro() {
      ctx.fillStyle = "orange";
      ctx.textBaseline = "top";
      ctx.font = "20px sans-serif";
      ctx.fillText('Press any key to start', canvas.width/2, canvas.height/2)
	}

	function draw_game_over(score) {
      ctx.fillStyle = "orange";
      ctx.textBaseline = "top";
      ctx.font = "20px sans-serif";
      ctx.fillText('Game over! Final score: ' + score, canvas.width/2, canvas.height/2)
	}

    function draw_hud(score,lives) {
      ctx.fillStyle = "orange";
      ctx.textBaseline = "top";
      ctx.font = "20px sans-serif";
      ctx.fillText('Score: ' + score, 10, 10)
      ctx.fillText('Lives: ' + lives, 10, 30)
    }

	function draw_bounds(x,y,w,h) {
		ctx.strokeStyle = "orange";
		ctx.beginPath();
		ctx.moveTo(x,y);
		ctx.lineTo(x+w,y);
		ctx.lineTo(x+w,y+h);
		ctx.lineTo(x,y+h);
		ctx.lineTo(x,y);
		ctx.stroke();
	}

	// this just doesn't work
	function draw_sprite(sprite_id, frame_index, x, y) {
		if (sprites[sprite_id] != "undefined" && sprites[sprite_id][frame_index] != "undefined") {
			ctx.putImageData(sprites[sprite_id][frame_index].image_data, x, y);
		}
	}

	function draw_debug(a,b,c,d) {
	  ctx.fillStyle = "orange";
      ctx.textBaseline = "top";
      ctx.font = "20px sans-serif";
      ctx.fillText('Debug: ' + a, 10, 50)
      ctx.fillText('Debug: ' + b, 10, 70)
      ctx.fillText('Debug: ' + c, 10, 90)
      ctx.fillText('Debug: ' + d, 10, 110)
	}

    // The real loading and running of our wasm starts here
    let imports = { clear_screen, draw_player, draw_bullet, draw_particle, draw_hud, draw_debug, draw_bounds, draw_intro, draw_game_over, draw_sprite };
    imports.Math_atan = Math.atan;
    imports.sin = Math.sin;
    imports.cos = Math.cos;
    return imports;
  }

  // Fetch and instantiate our wasm module
  fetch("program.wasm").then(response =>
    response.arrayBuffer()
  ).then(bytes =>
    WebAssembly.instantiate(bytes, { env: imports() })
  ).then(results => {
    let module = {};
    let mod = results.instance;
    module.update = mod.exports.update;
	module.key_pressed = mod.exports.key_pressed;
    module.toggle_fire = mod.exports.toggle_fire;
    module.toggle_left = mod.exports.toggle_left;
    module.toggle_right = mod.exports.toggle_right;
    module.resize = mod.exports.resize;
    module.draw = mod.exports.draw;
	module.init = mod.exports.init;

	module.init();

    // Input processing
    function processKey(key, b) {
      switch (key) {
        case "ArrowLeft":
          module.toggle_left(b);
          break;
        case "ArrowRight":
          module.toggle_right(b);
          break;
        case " ":
          module.toggle_fire(b);
          break;
      }
	  module.key_pressed(key, b);
    }
    document.addEventListener('keydown', e => processKey(e.key, true));
    document.addEventListener('keyup', e => processKey(e.key, false));

	function init_sprites(res) {
		let enemy1_0 = [
			0,0,1,0,0,0,0,0,1,0,0,
			0,0,0,1,0,0,0,1,0,0,0,
			0,0,1,1,1,1,1,1,1,0,0,
			0,1,1,0,1,1,1,0,1,1,0,
			1,1,1,1,1,1,1,1,1,1,1,
			1,0,1,1,1,1,1,1,1,0,1,
			1,0,1,0,0,0,0,0,1,0,1,
			0,0,0,1,1,0,1,1,0,0,0
		];

		let enemy1_1 = [
			0,0,1,0,0,0,0,0,1,0,0,
			1,0,0,1,0,0,0,1,0,0,1,
			1,0,1,1,1,1,1,1,1,0,1,
			1,1,1,0,1,1,1,0,1,1,1,
			1,1,1,1,1,1,1,1,1,1,1,
			0,0,1,1,1,1,1,1,1,0,0,
			0,0,1,0,0,0,0,0,1,0,0,
			0,1,0,0,0,0,0,0,0,1,0
		];

		init_sprite_frame_js(res, 0, 0, enemy1_0, 11, 8);
		init_sprite_frame_js(res, 0, 1, enemy1_1, 11, 8);
	}

	function init_sprite_frame_js(res, sprite_id, frame_index, data, w, h) {

		if (typeof(sprites[sprite_id]) == "undefined") {
			sprites[sprite_id] = [];
		}

		// TODO does this leak if we call this multiple times?
		sprites[sprite_id][frame_index] = {
			image_data: canvas.getContext("2d").createImageData(w,h),
			w: w,
			h: h
		}
		for (var i=0;i<w;++i) {
			for (var j=0;j<h;++j) {
					var source_index = j*w + i;
					var dest_index = source_index*4;
					var value = data[source_index] > 0 ? 255 : 0;
					sprites[sprite_id][frame_index].image_data.data[dest_index] = value;
					sprites[sprite_id][frame_index].image_data.data[dest_index+1] = value;
					sprites[sprite_id][frame_index].image_data.data[dest_index+2] = value;
					sprites[sprite_id][frame_index].image_data.data[dest_index+3] = 255;
			}
		}
	}

    // Resizing
    function resize() {
      // We make the canvas somewhat smaller to get some zooming
      canvas.width = window.innerWidth * 0.8;
      canvas.height = window.innerHeight * 0.8;
      module.resize(canvas.width, canvas.height);
	  init_sprites();
    }
    window.addEventListener('resize', () => {
      resize();
    });

    // Game loop
    let start = null;
    let prevTimestamp = null;
    let drawAndUpdate = (timestamp) => {
      // Initialization
      if (!prevTimestamp) {
        start = timestamp;
        prevTimestamp = timestamp;
        requestAnimationFrame(drawAndUpdate);
        return;
      }

      // Update and draw
      let progress = (timestamp - prevTimestamp) / 1000;
      module.update(progress);
      module.draw();

      // Some bookkeeping
      prevTimestamp = timestamp;
      requestAnimationFrame(drawAndUpdate);
    };

    resize();
    drawAndUpdate();
  });
  </script>
  </body>
</html>