<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <style>
      html, body {
        width: 100%;
        height: 100%;
        margin: 0px;
        border: 0;
        overflow: hidden; /*  Disable scrollbars */
        display: block;  /* No floating content on sides */
      }
      </style>
  </head>

  <body>
    <canvas id="canvas" style='position:absolute; left:0px; top:0px; width: 100%'></canvas>

<script>

let sprites = [];

  // Returns an object containing resources that will be used later for drawing
  function resources() {
    let res = {
      player: document.createElement('canvas'),
      enemy: document.createElement('canvas'),
      bullet: document.createElement('canvas'),
      player_bullet: document.createElement('canvas'),
      particle: document.createElement('canvas'),
	  shields: {},
	  shield_hit: canvas.getContext("2d").createImageData(40,40) // TODO scale shields
    }

    // Particle
    res.particle.width = 20;
    res.particle.height = 20;

    // Bullet
    res.bullet.width = 6;
    res.bullet.height = 6;
    let bCtx = res.bullet.getContext('2d');
    bCtx.fillStyle = "white";
    bCtx.beginPath();
    bCtx.arc(3, 3, 3, 0, 2 * Math.PI);
    bCtx.fill();

	res.player_bullet.width = 2;
    res.player_bullet.height = 40;
    let bpCtx = res.player_bullet.getContext('2d');
    bpCtx.fillStyle = "red";
	bpCtx.beginPath();
    bpCtx.lineTo(2, 40);
    bpCtx.lineTo(4, 0);
    bpCtx.lineTo(0, 0);
    bpCtx.fill();

	// Enemy
    res.enemy.width = 20;
    res.enemy.height = 20;
    let eCtx = res.enemy.getContext('2d');
    eCtx.fillStyle = "yellow";
    eCtx.beginPath();
    eCtx.arc(10, 10, 10, 0, 2 * Math.PI);
    eCtx.fill();

    // Player
    res.player.width = 20;
    res.player.height = 16;
    let plCtx = res.player.getContext('2d');
    plCtx.fillStyle = "red";
    plCtx.beginPath();
    plCtx.lineTo(20, 8);
    plCtx.lineTo(0, 16);
    plCtx.lineTo(0, 0);
    plCtx.fill();

    return res;
  }

  // We create this here because it will be used from within `imports`
  let canvas = document.getElementById('canvas');

  // Returns an object containing functions that will be linked to our wasm model
  // This means that they can be called from Rust
  function imports() {
    const res = resources();
    var ctx = canvas.getContext("2d");

    function clear_screen() {
      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function draw_player(x, y, angle) {
      ctx.translate(x, y);
      ctx.rotate(angle);
      ctx.translate(0, -8);
      ctx.drawImage(res.player, 0, 0);
      ctx.setTransform(1, 0, 0, 1, 0, 0);


      ctx.fillStyle = "black";
      //ctx.fillRect(x - 17, y - 12, 4, 4);
    }

	function draw_ufo(x, y) {
		ctx.putImageData(sprites[99][0].image_data, x, y);
    }

    function draw_bullet(x, y) {
      ctx.drawImage(res.bullet, x - 3, y - 3);
    }

	function draw_player_bullet(x, y) {
      ctx.drawImage(res.player_bullet, x - 3, y - 3);
    }

    function draw_particle(x, y, radius, color) {
	let pCtx = res.particle.getContext('2d');
	if (color == 1) {
		pCtx.fillStyle = "blue";
	} else if (color == 2) {
		pCtx.fillStyle = "red";
	} else {
		pCtx.fillStyle = "white";
	}
    pCtx.beginPath();
    pCtx.arc(10, 10, 10, 0, 2 * Math.PI);
    pCtx.fill();
      ctx.drawImage(res.particle, x - radius, y - radius, 2 * radius, 2 * radius);
    }

	function draw_intro() {
      ctx.fillStyle = "orange";
      ctx.textBaseline = "top";
      ctx.font = "20px sans-serif";
      ctx.fillText('Press any key to start', canvas.width/2, canvas.height/2)
	}

	function draw_game_over(score) {
      ctx.fillStyle = "orange";
      ctx.textBaseline = "top";
      ctx.font = "20px sans-serif";
      ctx.fillText('Game over! Final score: ' + score, canvas.width/2, canvas.height/2)
	}

    function draw_hud(score,lives) {
      ctx.fillStyle = "orange";
      ctx.textBaseline = "top";
      ctx.font = "20px sans-serif";
      ctx.fillText('Score: ' + score, 10, 10)
      ctx.fillText('Lives: ' + lives, 10, 30)
    }

	function draw_bounds(x,y,w,h) {
		ctx.strokeStyle = "orange";
		ctx.beginPath();
		ctx.moveTo(x,y);
		ctx.lineTo(x+w,y);
		ctx.lineTo(x+w,y+h);
		ctx.lineTo(x,y+h);
		ctx.lineTo(x,y);
		ctx.stroke();
	}

	function init_shield(id) {
		res.shields[id] = [];
	}

	function add_shield_state(id, index, state) {
		res.shields[id][index] = state;
	}

	function update_shield(id, index, state) {
		if (res.shields[id] != "undefined")
		res.shields[id][index] = state;
	}

	function draw_shield(id, x, y, dim) {
// TODO do we want to do a pattern?
//		pattern = ctx.createPattern(image, repetition);
		for (var i=0;i<25;++i) {
			var state = res.shields[id][i];
			var xoffset = (i % 5) * dim;
			var yoffset = Math.trunc(i / 5) * dim;
			if (state == 1) { // BlockState::Hit
				ctx.fillStyle = "darkred";
				ctx.fillRect(x + xoffset, y + yoffset, dim, dim);
			} else if (state == 2) { // BlockState::Full
				ctx.fillStyle = "red";
				ctx.fillRect(x + xoffset, y + yoffset, dim, dim);
			}
		}
	}

	function draw_sprite(sprite_id, frame_index, x, y) {
		if (sprites[sprite_id] != "undefined" && sprites[sprite_id][frame_index] != "undefined") {
			ctx.putImageData(sprites[sprite_id][frame_index].image_data, x, y);
		}
	}

	function draw_debug(a,b,c,d) {
	  ctx.fillStyle = "orange";
      ctx.textBaseline = "top";
      ctx.font = "20px sans-serif";
      ctx.fillText('Debug: ' + a, 10, 50)
      ctx.fillText('Debug: ' + b, 10, 70)
      ctx.fillText('Debug: ' + c, 10, 90)
      ctx.fillText('Debug: ' + d, 10, 110)
	}

    // The real loading and running of our wasm starts here
    let imports = { clear_screen, draw_player, draw_bullet, draw_player_bullet, draw_particle, draw_hud, draw_debug, draw_bounds, draw_intro, draw_game_over, draw_sprite, init_shield, add_shield_state, update_shield, draw_shield, draw_ufo };
    imports.Math_atan = Math.atan;
    imports.sin = Math.sin;
    imports.cos = Math.cos;
    return imports;
  }

  // Fetch and instantiate our wasm module
  fetch("program.wasm").then(response =>
    response.arrayBuffer()
  ).then(bytes =>
    WebAssembly.instantiate(bytes, { env: imports() })
  ).then(results => {
    let module = {};
    let mod = results.instance;
    module.update = mod.exports.update;
	module.key_pressed = mod.exports.key_pressed;
    module.toggle_fire = mod.exports.toggle_fire;
    module.toggle_left = mod.exports.toggle_left;
    module.toggle_right = mod.exports.toggle_right;
    module.resize = mod.exports.resize;
    module.draw = mod.exports.draw;
	module.init = mod.exports.init;

	module.init();

    // Input processing
    function processKey(key, b) {
      switch (key) {
        case "ArrowLeft":
          module.toggle_left(b);
          break;
        case "ArrowRight":
          module.toggle_right(b);
          break;
        case " ":
          module.toggle_fire(b);
          break;
      }
	  module.key_pressed(key, b);
    }
    document.addEventListener('keydown', e => processKey(e.key, true));
    document.addEventListener('keyup', e => processKey(e.key, false));

	/*
	Sprites are 12x12, and the enemy game radius is 24
	So we double the sprites when we init, and then when we render we need to scale by game to screen
	*/
	function init_sprites(scale) {
		let enemy0_0 = [
			0,0,1,0,0,0,0,0,1,0,0,0,
			0,0,0,1,0,0,0,1,0,0,0,0,
			0,0,1,1,1,1,1,1,1,0,0,0,
			0,1,1,0,1,1,1,0,1,1,0,0,
			1,1,1,1,1,1,1,1,1,1,1,0,
			1,0,1,1,1,1,1,1,1,0,1,0,
			1,0,1,0,0,0,0,0,1,0,1,0,
			0,0,0,1,1,0,1,1,0,0,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0
		];

		let enemy0_1 = [
			0,0,1,0,0,0,0,0,1,0,0,0,
			1,0,0,1,0,0,0,1,0,0,1,0,
			1,0,1,1,1,1,1,1,1,0,1,0,
			1,1,1,0,1,1,1,0,1,1,1,0,
			1,1,1,1,1,1,1,1,1,1,1,0,
			0,0,1,1,1,1,1,1,1,0,0,0,
			0,0,1,0,0,0,0,0,1,0,0,0,
			0,1,0,0,0,0,0,0,0,1,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0
		];

		let enemy1_0 = [
			0,0,0,0,0,1,1,0,0,0,0,0,
			0,0,0,0,1,1,1,1,0,0,0,0,
			0,0,0,1,1,1,1,1,1,0,0,0,
			0,0,1,1,0,1,1,0,1,1,0,0,
			0,0,1,1,1,1,1,1,1,1,0,0,
			0,0,0,1,0,1,1,0,1,0,0,0,
			0,0,1,0,0,0,0,0,0,1,0,0,
			0,0,0,1,0,0,0,0,1,0,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0,
		];

		let enemy1_1 = [
			0,0,0,0,0,1,1,0,0,0,0,0,
			0,0,0,0,1,1,1,1,0,0,0,0,
			0,0,0,1,1,1,1,1,1,0,0,0,
			0,0,1,1,0,1,1,0,1,1,0,0,
			0,0,1,1,1,1,1,1,1,1,0,0,
			0,0,0,0,1,0,0,1,0,0,0,0,
			0,0,0,1,0,1,1,0,1,0,0,0,
			0,0,1,0,1,0,0,1,0,1,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0,
		];

		let enemy2_0 = [
			0,0,0,0,0,1,1,0,0,0,0,0,
			0,0,0,1,1,1,1,1,1,0,0,0,
			0,0,1,1,1,1,1,1,1,1,0,0,
			0,0,1,1,0,0,1,0,0,1,0,0,
			0,0,1,1,1,1,1,1,1,1,0,0,
			0,0,0,1,1,0,0,1,1,0,0,0,
			0,0,1,1,0,0,0,0,1,1,0,0,
			0,0,0,1,1,0,0,1,1,0,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0,
		];

		let enemy2_1 = [
			0,0,0,0,0,1,1,0,0,0,0,0,
			0,0,0,1,1,1,1,1,1,0,0,0,
			0,0,1,1,1,1,1,1,1,1,0,0,
			0,0,1,1,0,0,1,0,0,1,0,0,
			0,0,1,1,1,1,1,1,1,1,0,0,
			0,0,0,1,1,0,0,1,1,0,0,0,
			0,0,1,1,0,1,1,0,1,1,0,0,
			0,1,1,0,0,0,0,0,0,1,1,0,
			0,0,0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0,
		];

		let ufo = [
			0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,
			0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,
			0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
			0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,
			1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
			0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,0,
			0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		];

		init_sprite_frame(0, 0, enemy0_0, 12, scale*3, 255, 255, 255);
		init_sprite_frame(0, 1, enemy0_1, 12, scale*3, 255, 255, 255);
		init_sprite_frame(1, 0, enemy1_0, 12, scale*3, 255, 255, 255);
		init_sprite_frame(1, 1, enemy1_1, 12, scale*3, 255, 255, 255);
		init_sprite_frame(2, 0, enemy2_0, 12, scale*3, 255, 255, 255);
		init_sprite_frame(2, 1, enemy2_1, 12, scale*3, 255, 255, 255);
		init_sprite_frame(99,0, ufo, 16, scale*3, 0, 0, 255);
	}

	function init_sprite_frame(sprite_id, frame_index, data, orig_dim, scale, r, g, b) {

		let final_size = Math.floor(scale * orig_dim);

		if (typeof(sprites[sprite_id]) == "undefined") {
			sprites[sprite_id] = [];
		}

		// TODO does this leak if we call this multiple times?
		sprites[sprite_id][frame_index] = {
			image_data: canvas.getContext("2d").createImageData(final_size,final_size),
			w: final_size,
			h: final_size
		}
		for (var j=0;j<final_size;++j) {
			for (var i=0;i<final_size;++i) {
				var dest_index = i + j*final_size;
				var source_index = Math.floor(i/scale) + Math.floor(j/scale) * orig_dim;
				sprites[sprite_id][frame_index].image_data.data[4*dest_index] = data[source_index] > 0 ? r : 0;
				sprites[sprite_id][frame_index].image_data.data[4*dest_index+1] = data[source_index] > 0 ? g : 0;
				sprites[sprite_id][frame_index].image_data.data[4*dest_index+2] = data[source_index] > 0 ? b : 0;
				sprites[sprite_id][frame_index].image_data.data[4*dest_index+3] = 255;
			}
		}
	}

    // Resizing
    function resize() {
      // We make the canvas somewhat smaller to get some zooming
      canvas.width = window.innerWidth * 1;
      canvas.height = window.innerHeight * 1;
      let scale = module.resize(canvas.width, canvas.height);
	  init_sprites(scale);
    }
    window.addEventListener('resize', () => {
      resize();
    });

    // Game loop
    let start = null;
    let prevTimestamp = null;
    let drawAndUpdate = (timestamp) => {
      // Initialization
      if (!prevTimestamp) {
        start = timestamp;
        prevTimestamp = timestamp;
        requestAnimationFrame(drawAndUpdate);
        return;
      }

      // Update and draw
      let progress = (timestamp - prevTimestamp) / 1000;
      module.update(progress);
      module.draw();

      // Some bookkeeping
      prevTimestamp = timestamp;
      requestAnimationFrame(drawAndUpdate);
    };

    resize();
    drawAndUpdate();
  });
  </script>
  </body>
</html>